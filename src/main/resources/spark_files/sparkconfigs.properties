spark的配置优先级：sparkConf  spark-submit -conf   spark-defalut.env  spark-env.sh
#谁最后谁优先...
简单易懂的不必翻译了
Application Properties
spark.app.name	(none)	The name of your application. This will appear in the UI and in log data.
#任务名，在真正submit的时候最好注释掉，然后通过spark-submit --name "APPNAME"来指定！

spark.driver.cores	1	Number of cores to use for the driver process, only in cluster mode.
#同样是在submit的时候指定--diver-cores

spark.driver.maxResultSize	1g	Limit of total size of serialized results of all partitions for each Spark action (e.g. collect) in bytes. Should be at least 1M, or 0 for unlimited. Jobs will be aborted if the total size is above this limit. Having a high limit may cause out-of-memory errors in driver (depends on spark.driver.memory and memory overhead of objects in JVM). Setting a proper limit can protect the driver from out-of-memory errors.
#driver端可以拉回的数据量限制：防止OOM

spark.driver.memory	1g	Amount of memory to use for the driver process, i.e. where SparkContext is initialized, in the same format as JVM memory strings with a size unit suffix ("k", "m", "g" or "t") (e.g. 512m, 2g).
#在submit的时候配置，不然就会根据默认的JVM heap size来创建

spark.driver.memoryOverhead	driverMemory * 0.10, with minimum of 384	The amount of off-heap memory to be allocated per driver in cluster mode, in MiB unless otherwise specified. This is memory that accounts for things like VM overheads, interned strings, other native overheads, etc. This tends to grow with the container size (typically 6-10%). This option is currently supported on YARN and Kubernetes.
#可以超过的量 off-heap，堆外内存，可以使用并且不会经常被GC

spark.executor.memory	1g	Amount of memory to use per executor process, in the same format as JVM memory strings with a size unit suffix ("k", "m", "g" or "t") (e.g. 512m, 2g).
#submit时候配置

spark.executor.pyspark.memory	Not set	The amount of memory to be allocated to PySpark in each executor, in MiB unless otherwise specified. If set, PySpark memory for an executor will be limited to this amount. If not set, Spark will not limit Python's memory use and it is up to the application to avoid exceeding the overhead memory space shared with other non-JVM processes. When PySpark is run in YARN or Kubernetes, this memory is added to executor resource requests.
#因为并不是用的JVM所以不设置就不受限

spark.executor.memoryOverhead	executorMemory * 0.10, with minimum of 384	The amount of off-heap memory to be allocated per executor, in MiB unless otherwise specified. This is memory that accounts for things like VM overheads, interned strings, other native overheads, etc. This tends to grow with the executor size (typically 6-10%). This option is currently supported on YARN and Kubernetes.
#同driver.memoeyOverhead

spark.extraListeners	(none)	A comma-separated list of classes that implement SparkListener; when initializing SparkContext, instances of these classes will be created and registered with Spark's listener bus. If a class has a single-argument constructor that accepts a SparkConf, that constructor will be called; otherwise, a zero-argument constructor will be called. If no valid constructor can be found, the SparkContext creation will fail with an exception.
#监听sparkcontext的class

spark.local.dir	/tmp	Directory to use for "scratch" space in Spark, including map output files and RDDs that get stored on disk. This should be on a fast, local disk in your system. It can also be a comma-separated list of multiple directories on different disks. NOTE: In Spark 1.0 and later this will be overridden by SPARK_LOCAL_DIRS (Standalone), MESOS_SANDBOX (Mesos) or LOCAL_DIRS (YARN) environment variables set by the cluster manager.
#map输出和rdd的disk的位置，所以需要快并大的空间，如果不是yarn模式的haunted需要改变/tmp这个默认值，yarn模式的话是hadoop中配置的hadoop.tmp.dir

spark.logConf	false	Logs the effective SparkConf as INFO when a SparkContext is started.

spark.master	(none)	The cluster manager to connect to. See the list of allowed master URL's.
#集群模式的话时yarn说了算

spark.submit.deployMode	(none)	The deploy mode of Spark driver program, either "client" or "cluster", Which means to launch driver program locally ("client") or remotely ("cluster") on one of the nodes inside the cluster.
#submit的时候配置 --deploy-mode cluster

spark.log.callerContext	(none)	Application information that will be written into Yarn RM log/HDFS audit log when running on Yarn/HDFS. Its length depends on the Hadoop configuration hadoop.caller.context.max.size. It should be concise, and typically can have up to 50 characters.

spark.driver.supervise	false	If true, restarts the driver automatically if it fails with a non-zero exit status. Only has effect in Spark standalone mode or Mesos cluster deploy mode.
#自动无报错重启，但是不适合yarn

Runtime Evironment
spark.driver.extraClassPath	(none)	Extra classpath entries to prepend to the classpath of the driver. 
#额外的class，需要注意的是如果是集群模式可以在程序中，配置文件，sumit中配置，但是local模式下不能在代码中配置...

spark.driver.extraJavaOptions	(none)	A string of extra JVM options to pass to the driver. For instance, GC settings or other logging. Note that it is illegal to set maximum heap size (-Xmx) settings with this option. Maximum heap size settings can be set with spark.driver.memory in the cluster mode and through the --driver-memory command line option in the client mode. 
#针对driver设置的额外的JVM配置比如GC设置，注意不能设置heap size或者memory，因为这俩或者雷士是用配置项或者submit来设置的
#并且更上面一样如果是local模式不能设置在代码中，怪不得我想在本地看GC情况看不到！！！！！！

spark.driver.extraLibraryPath	(none)	Set a special library path to use when launching the driver JVM. 
#指定非JAVA库文件路径

spark.driver.userClassPathFirst	false	(Experimental) Whether to give user-added jars precedence over Spark's own jars when loading classes in the driver. This feature can be used to mitigate conflicts between Spark's dependencies and user dependencies. It is currently an experimental feature. This is used in cluster mode only.
#可能存在冲突

spark.executor.extraClassPath	(none)	Extra classpath entries to prepend to the classpath of executors. This exists primarily for backwards-compatibility with older versions of Spark. Users typically should not need to set this option.
#不需要设置

**************可调试**********
spark.executor.extraJavaOptions	(none)	A string of extra JVM options to pass to executors. For instance, GC settings or other logging. Note that it is illegal to set Spark properties or maximum heap size (-Xmx) settings with this option. Spark properties should be set using a SparkConf object or the spark-defaults.conf file used with the spark-submit script. Maximum heap size settings can be set with spark.executor.memory. The following symbols, if present will be interpolated: will be replaced by application ID and will be replaced by executor ID. For example, to enable verbose gc logging to a file named for the executor ID of the app in /tmp, pass a 'value' of: -verbose:gc -Xloggc:/tmp/-.gc
#executor额外的java配置项，同样的比如GC
*****************************

spark.executor.extraLibraryPath	(none)	Set a special library path to use when launching executor JVM's.

**************如果不是yarn模式的话需要配置上***********
spark.executor.logs.rolling.maxRetainedFiles	(none)	Sets the number of latest rolling log files that are going to be retained by the system. Older log files will be deleted. Disabled by default.
#executor的日志文件数量的限制

spark.executor.logs.rolling.enableCompression	false	Enable executor log compression. If it is enabled, the rolled executor logs will be compressed. Disabled by default.
#executor的日志是否压缩，其实没有必要

spark.executor.logs.rolling.maxSize	(none)	Set the max size of the file in bytes by which the executor logs will be rolled over. Rolling is disabled by default. See spark.executor.logs.rolling.maxRetainedFiles for automatic cleaning of old logs.
#其实和rolling.maxretainedfiles相结合的，这个是配置每个日志文件的大小，综合起来就是保存日志量的大小

spark.executor.logs.rolling.strategy	(none)	Set the strategy of rolling of executor logs. By default it is disabled. It can be set to "time" (time-based rolling) or "size" (size-based rolling). For "time", use spark.executor.logs.rolling.time.interval to set the rolling interval. For "size", use spark.executor.logs.rolling.maxSize to set the maximum file size for rolling.
#选择日志文件生成的策略，可以选择time inteval和size

spark.executor.logs.rolling.time.interval	daily	Set the time interval by which the executor logs will be rolled over. Rolling is disabled by default. Valid values are daily, hourly, minutely or any interval in seconds. See spark.executor.logs.rolling.maxRetainedFiles for automatic cleaning of old logs.
#按照时间来生成日志文件

spark.executor.userClassPathFirst	false	(Experimental) Same functionality as spark.driver.userClassPathFirst, but applied to executor instances.

spark.executorEnv.[EnvironmentVariableName]	(none)	Add the environment variable specified by EnvironmentVariableName to the Executor process. The user can specify multiple of these to set multiple environment variables.
#设置executor的环境变量

*************可以试一下***********
spark.redaction.regex	(?i)secret|password	Regex to decide which Spark configuration properties and environment variables in driver and executor environments contain sensitive information. When this regex matches a property key or value, the value is redacted from the environment UI and various logs like YARN and event logs.
#涉及私密信息的时候可以稍微隐藏一下

spark.python.profile	false	Enable profiling in Python worker, the profile result will show up by sc.show_profiles(), or it will be displayed before the driver exits. It also can be dumped into disk by sc.dump_profiles(path). If some of the profile results had been displayed manually, they will not be displayed automatically before driver exiting. By default the pyspark.profiler.BasicProfiler will be used, but this can be overridden by passing a profiler class in as a parameter to the SparkContext constructor.

spark.python.profile.dump	(none)	The directory which is used to dump the profile result before driver exiting. The results will be dumped as separated file for each RDD. They can be loaded by ptats.Stats(). If this is specified, the profile result will not be displayed automatically.

spark.python.worker.memory	512m	Amount of memory to use per python worker process during aggregation, in the same format as JVM memory strings with a size unit suffix ("k", "m", "g" or "t") (e.g. 512m, 2g). If the memory used during aggregation goes above this amount, it will spill the data into disks.

spark.python.worker.reuse	true	Reuse Python worker or not. If yes, it will use a fixed number of Python workers, does not need to fork() a Python process for every task. It will be very useful if there is large broadcast, then the broadcast will not be needed to transferred from JVM to Python worker for every task.

spark.files		Comma-separated list of files to be placed in the working directory of each executor. Globs are allowed.
#不需要

spark.submit.pyFiles		Comma-separated list of .zip, .egg, or .py files to place on the PYTHONPATH for Python apps. Globs are allowed.

spark.jars		Comma-separated list of jars to include on the driver and executor classpaths. Globs are allowed.
#最好是submit的时候

spark.jars.packages		Comma-separated list of Maven coordinates of jars to include on the driver and executor classpaths. The coordinates should be groupId:artifactId:version. If spark.jars.ivySettings is given artifacts will be resolved according to the configuration in the file, otherwise artifacts will be searched for in the local maven repo, then maven central and finally any additional remote repositories given by the command-line option --repositories. For more details, see Advanced Dependency Management.
#最好不要

spark.jars.excludes		Comma-separated list of groupId:artifactId, to exclude while resolving the dependencies provided in spark.jars.packages to avoid dependency conflicts.
#最好不要，如果存在冲突就解决，不然每次都这样必然不行

spark.jars.ivy		Path to specify the Ivy user directory, used for the local Ivy cache and package files from spark.jars.packages. This will override the Ivy property ivy.default.ivy.user.dir which defaults to ~/.ivy2.

spark.jars.ivySettings		Path to an Ivy settings file to customize resolution of jars specified using spark.jars.packages instead of the built-in defaults, such as maven central. Additional repositories given by the command-line option --repositories or spark.jars.repositories will also be included. Useful for allowing Spark to resolve artifacts from behind a firewall e.g. via an in-house artifact server like Artifactory. Details on the settings file format can be found at http://ant.apache.org/ivy/history/latest-milestone/settings.html

spark.jars.repositories		Comma-separated list of additional remote repositories to search for the maven coordinates given with --packages or spark.jars.packages.
#添加远程残酷的jars，最好不要

spark.pyspark.driver.python		Python binary executable to use for PySpark in driver. (default is spark.pyspark.python)
#指定执行diver的python解释器路径

spark.pyspark.python		Python binary executable to use for PySpark in both driver and executors.
#默认采用这个配置，指定执行driver和executor的python解释器路径

Shuffle Behavior
**************可以调优会提高速度，当然要考虑带宽问题*************
spark.reducer.maxSizeInFlight	48m	Maximum size of map outputs to fetch simultaneously from each reduce task, in MiB unless otherwise specified. Since each output requires us to create a buffer to receive it, this represents a fixed memory overhead per reduce task, so keep it small unless you have a large amount of memory.
#指定ruduce去拉取map端输出文件大小，存在堆外内存，所以适当配置

spark.reducer.maxReqsInFlight	Int.MaxValue	This configuration limits the number of remote requests to fetch blocks at any given point. When the number of hosts in the cluster increase, it might lead to very large number of inbound connections to one or more nodes, causing the workers to fail under load. By allowing it to limit the number of fetch requests, this scenario can be mitigated.
#限制远程请求数

spark.reducer.maxBlocksInFlightPerAddress	Int.MaxValue	This configuration limits the number of remote blocks being fetched per reduce task from a given host port. When a large number of blocks are being requested from a given address in a single fetch or simultaneously, this could crash the serving executor or Node Manager. This is especially useful to reduce the load on the Node Manager when external shuffle is enabled. You can mitigate this issue by setting it to a lower value.
#拉取数据块数量，但是应用外部shuffle比较有用

spark.maxRemoteBlockSizeFetchToMem	Int.MaxValue - 512	The remote block will be fetched to disk when size of the block is above this threshold in bytes. This is to avoid a giant request that takes too much memory. By default, this is only enabled for blocks > 2GB, as those cannot be fetched directly into memory, no matter what resources are available. But it can be turned down to a much lower value (eg. 200m) to avoid using too much memory on smaller blocks as well. Note this configuration will affect both shuffle fetch and block manager remote block fetch. For users who enabled external shuffle service, this feature can only be used when external shuffle service is newer than Spark 2.2.
#拉取数量快大小，应用外部shuffle比较有用

spark.shuffle.compress	true	Whether to compress map output files. Generally a good idea. Compression will use spark.io.compression.codec.
#是否压缩，肯定的啊

****************可以调优****************
spark.shuffle.file.buffer	32k	Size of the in-memory buffer for each shuffle file output stream, in KiB unless otherwise specified. These buffers reduce the number of disk seeks and system calls made in creating intermediate shuffle files.
#shuffle缓冲大小，可以适当提高，减少io

spark.shuffle.io.maxRetries	3	(Netty only) Fetches that fail due to IO-related exceptions are automatically retried if this is set to a non-zero value. This retry logic helps stabilize large shuffles in the face of long GC pauses or transient network connectivity issues.
#有时候可能因为网络、gc问题导致从write task端拉取数据到read task端，对于大量数据的shuffle尽量提高重试次数

spark.shuffle.io.numConnectionsPerPeer	1	(Netty only) Connections between hosts are reused in order to reduce connection buildup for large clusters. For clusters with many hard disks and few hosts, this may result in insufficient concurrency to saturate all disks, and so users may consider increasing this value.

spark.shuffle.io.preferDirectBufs	true	(Netty only) Off-heap buffers are used to reduce garbage collection during shuffle and cache block transfer. For environments where off-heap memory is tightly limited, users may wish to turn this off to force all allocations from Netty to be on-heap.
#使用堆外内存，尤其是shuffle的时候，因为shuffle的时候对象太多，为了减少gc

spark.shuffle.io.retryWait	5s	(Netty only) How long to wait between retries of fetches. The maximum delay caused by retrying is 15 seconds by default, calculated as maxRetries * retryWait.
#retry 等待时间

**************可以考虑************但是有一个特别大的隐患就是需要配置资源自动配置这个配置项，有些危险******
spark.shuffle.service.enabled	false	Enables the external shuffle service. This service preserves the shuffle files written by executors so the executors can be safely removed. This must be enabled if spark.dynamicAllocation.enabled is "true". The external shuffle service must be set up in order to enable it. See dynamic allocation configuration and setup documentation for more information.
#外部shuffle是否开启，可能会提高性能，可以通过在yarn-site.xml中配置，目的是用nodemanager来减轻exector的gc压力

spark.shuffle.service.port	7337	Port on which the external shuffle service will run.
#默认的

spark.shuffle.service.index.cache.size	100m	Cache entries limited to the specified memory footprint in bytes.

spark.shuffle.maxChunksBeingTransferred	Long.MAX_VALUE	The max number of chunks allowed to be transferred at the same time on shuffle service. Note that new incoming connections will be closed when the max number is hit. The client will retry according to the shuffle retry configs (see spark.shuffle.io.maxRetries and spark.shuffle.io.retryWait), if those limits are reached the task will fail with fetch failure.

spark.shuffle.sort.bypassMergeThreshold	200	(Advanced) In the sort-based shuffle manager, avoid merge-sorting data if there is no map-side aggregation and there are at most this many reduce partitions.
#最开始的shuffle是基于hashshuffle，该方式的弊端在于生成的小文件太多、reduce端如果需要接受的数据数太多也会造成并行压力
#后来出现基于sortshuffle，是从hadoop shuffle学习来的，利用了分区的原理
#这里的bypassmerger这里目的是避免产生大量的文件，这个阈值是200个partition数量

spark.shuffle.spill.compress	true	Whether to compress data spilled during shuffles. Compression will use spark.io.compression.codec.
#当然压缩

spark.shuffle.accurateBlockThreshold	100 * 1024 * 1024	Threshold in bytes above which the size of shuffle blocks in HighlyCompressedMapStatus is accurately recorded. This helps to prevent OOM by avoiding underestimating shuffle block size when fetch shuffle blocks.
#限制block大小阈值，避免OOM

spark.shuffle.registration.timeout	5000	Timeout in milliseconds for registration to the external shuffle service.
#外部shuffle的注册timeout

spark.shuffle.registration.maxAttempts	3	When we fail to register to the external shuffle service, we will retry for maxAttempts times.
#外部shuffle最大重试次数

SparkUI
spark.eventLog.logBlockUpdates.enabled	false	Whether to log events for every block update, if spark.eventLog.enabled is true. *Warning*: This will increase the size of the event log considerably.
#是否更新eventlog block，当然不

spark.eventLog.longForm.enabled	false	If true, use the long form of call sites in the event log. Otherwise use the short form.
#是否采用长的日志格式

spark.eventLog.compress	false	Whether to compress logged events, if spark.eventLog.enabled is true. Compression will use spark.io.compression.codec.
#是否压缩，可以压缩

spark.eventLog.dir	file:///tmp/spark-events	Base directory in which Spark events are logged, if spark.eventLog.enabled is true. Within this base directory, Spark creates a sub-directory for each application, and logs the events specific to the application in this directory. Users may want to set this to a unified location like an HDFS directory so history files can be read by the history server.
#eventlog的目录，在hdfs上

***************可以调优**************
spark.eventLog.enabled	false	Whether to log Spark events, useful for reconstructing the Web UI after the application has finished.
#看来最好打开，因为当任务结束后可以再看日志

spark.eventLog.overwrite	false	Whether to overwrite any existing files.
#是否重写，当然不

#***************可以调优**************
spark.eventLog.buffer.kb	100k	Buffer size to use when writing to output streams, in KiB unless otherwise specified.
#可以提高一下buffer，减少io

spark.ui.dagGraph.retainedRootRDDs	Int.MaxValue	How many DAG graph nodes the Spark UI and status APIs remember before garbage collecting.
#gc之前在ui上显示多少DAG图

spark.ui.enabled	true	Whether to run the web UI for the Spark application.
#当然

spark.ui.killEnabled	true	Allows jobs and stages to be killed from the web UI.
#是否可以杀掉在UI上

spark.ui.liveUpdate.period	100ms	How often to update live entities. -1 means "never update" when replaying applications, meaning only the last write will happen. For live applications, this avoids a few operations that we can live without when rapidly processing incoming task events.
#刷新时间

spark.ui.port	4040	Port for your application's dashboard, which shows memory and workload data.
#ui端口

spark.ui.retainedJobs	1000	How many jobs the Spark UI and status APIs remember before garbage collecting. This is a target maximum, and fewer elements may be retained in some circumstances.
#ui上保留多少job

spark.ui.retainedStages	1000	How many stages the Spark UI and status APIs remember before garbage collecting. This is a target maximum, and fewer elements may be retained in some circumstances.
#保留多少stage

spark.ui.retainedTasks	100000	How many tasks the Spark UI and status APIs remember before garbage collecting. This is a target maximum, and fewer elements may be retained in some circumstances.
#保留多少task

spark.ui.reverseProxy	false	Enable running Spark Master as reverse proxy for worker and application UIs. In this mode, Spark master will reverse proxy the worker and application UIs to enable access without requiring direct access to their hosts. Use it with caution, as worker and application UI will not be accessible directly, you will only be able to access them through spark master/proxy public URL. This setting affects all the workers and application UIs running in the cluster and must be set on all the workers, drivers and masters.

spark.ui.reverseProxyUrl		This is the URL where your proxy is running. This URL is for proxy which is running in front of Spark Master. This is useful when running proxy for authentication e.g. OAuth proxy. Make sure this is a complete URL including scheme (http/https) and port to reach your proxy.

spark.ui.showConsoleProgress	true	Show the progress bar in the console. The progress bar shows the progress of stages that run for longer than 500ms. If multiple stages run at the same time, multiple progress bars will be displayed on the same line.

spark.worker.ui.retainedExecutors	1000	How many finished executors the Spark UI and status APIs remember before garbage collecting.
#保留多少exectors

spark.worker.ui.retainedDrivers	1000	How many finished drivers the Spark UI and status APIs remember before garbage collecting.
#保留多少driver

spark.sql.ui.retainedExecutions	1000	How many finished executions the Spark UI and status APIs remember before garbage collecting.

#spark.streaming.ui.retainedBatches	1000	How many finished batches the Spark UI and status APIs remember before garbage collecting.

#spark.ui.retainedDeadExecutors	100	How many dead executors the Spark UI and status APIs remember before garbage collecting.

#spark.ui.filters	None	Comma separated list of filter class names to apply to the Spark Web UI. The filter should be a standard javax servlet Filter.
#Filter parameters can also be specified in the configuration, by setting config entries of the form spark.<class name of filter>.param.<param name>=<value>
#For example:
#spark.ui.filters=com.test.filter1
#spark.com.test.filter1.param.name1=foo
#spark.com.test.filter1.param.name2=bar


Compression and Serialization
************默认就是压缩的**********
spark.broadcast.compress	true	Whether to compress broadcast variables before sending them. Generally a good idea. Compression will use spark.io.compression.codec.
#广播是否压缩

spark.io.compression.codec	lz4	The codec used to compress internal data such as RDD partitions, event log, broadcast variables and shuffle outputs. By default, Spark provides four codecs: lz4, lzf, snappy, and zstd. You can also use fully qualified class names to specify the codec, e.g. org.apache.spark.io.LZ4CompressionCodec, org.apache.spark.io.LZFCompressionCodec, org.apache.spark.io.SnappyCompressionCodec, and org.apache.spark.io.ZStdCompressionCodec.
#选择压缩方式

spark.io.compression.lz4.blockSize	32k	Block size in bytes used in LZ4 compression, in the case when LZ4 compression codec is used. Lowering this block size will also lower shuffle memory usage when LZ4 is used.
#压缩块大小

spark.io.compression.snappy.blockSize	32k	Block size in bytes used in Snappy compression, in the case when Snappy compression codec is used. Lowering this block size will also lower shuffle memory usage when Snappy is used.

**************可以调优，但是应该没有大的必要************
spark.io.compression.zstd.level	1	Compression level for Zstd compression codec. Increasing the compression level will result in better compression at the expense of more CPU and memory.
#压缩等级，用cpu使用来交换

************可以调优哦****************
spark.io.compression.zstd.bufferSize	32k	Buffer size in bytes used in Zstd compression, in the case when Zstd compression codec is used. Lowering this size will lower the shuffle memory usage when Zstd is used, but it might increase the compression cost because of excessive JNI call overhead.

spark.kryo.classesToRegister	(none)	If you use Kryo serialization, give a comma-separated list of custom class names to register with Kryo. See the tuning guide for more details.
#需要注册为可以被kryo序列化的类

spark.kryo.referenceTracking	true	Whether to track references to the same object when serializing data with Kryo, which is necessary if your object graphs have loops and useful for efficiency if they contain multiple copies of the same object. Can be disabled to improve performance if you know this is not the case.
#是否跟踪同一个对象，如果是的话不必多次序列化

spark.kryo.registrationRequired	false	Whether to require registration with Kryo. If set to 'true', Kryo will throw an exception if an unregistered class is serialized. If set to false (the default), Kryo will write unregistered class names along with each object. Writing class names can cause significant performance overhead, so enabling this option can enforce strictly that a user has not omitted classes from registration.
#如果是true，就是强制必须注册，如果是没有注册为kryo可以序列化的class的话，就会报错。所以设置为false

spark.kryo.registrator	(none)	If you use Kryo serialization, give a comma-separated list of classes that register your custom classes with Kryo. This property is useful if you need to register your classes in a custom way, e.g. to specify a custom field serializer. Otherwise spark.kryo.classesToRegister is simpler. It should be set to classes that extend KryoRegistrator. See the tuning guide for more details.
#最好设置上

***************视情况而定**************
spark.kryo.unsafe	false	Whether to use unsafe based Kryo serializer. Can be substantially faster by using Unsafe Based IO.
#是否想使用不安全的kryo序列化，反正是更快

**************可以调优***************
spark.kryoserializer.buffer.max	64m	Maximum allowable size of Kryo serialization buffer, in MiB unless otherwise specified. This must be larger than any object you attempt to serialize and must be less than 2048m. Increase this if you get a "buffer limit exceeded" exception inside Kryo.
#序列化buffer

spark.kryoserializer.buffer	64k	Initial size of Kryo's serialization buffer, in KiB unless otherwise specified. Note that there will be one buffer per core on each worker. This buffer will grow up to spark.kryoserializer.buffer.max if needed.
#buffer初始化大小，可以逐渐增加到buffer.max

************可以调优**********很多情况下是内存和cpu的权衡**************
spark.rdd.compress	false	Whether to compress serialized RDD partitions (e.g. for StorageLevel.MEMORY_ONLY_SER in Java and Scala or StorageLevel.MEMORY_ONLY in Python). Can save substantial space at the cost of some extra CPU time. Compression will use spark.io.compression.codec.
#是否压缩序列化后的rdd partitions

spark.serializer	org.apache.spark.serializer.
#指定kryo序列化列
#JavaSerializer	Class to use for serializing objects that will be sent over the network or need to be cached in serialized form. The default of Java serialization works with any Serializable Java object but is quite slow, so we recommend using org.apache.spark.serializer.KryoSerializer and configuring Kryo serialization when speed is necessary. Can be any subclass of org.apache.spark.Serializer.

********************可以调优****************
spark.serializer.objectStreamReset	100	When serializing using org.apache.spark.serializer.JavaSerializer, the serializer caches objects to prevent writing redundant data, however that stops garbage collection of those objects. By calling 'reset' you flush that info from the serializer, and allow old objects to be collected. To turn off this periodic reset set it to -1. By default it will reset the serializer every 100 objects.
#JavaSerializer序列化对象的时候会缓存一部分对象，目的是防止重复写，这部分对象不会被GC，设置100的意思是每100个对象就rest为0，重新缓存

Meory Management
spark.memory.fraction	0.6	Fraction of (heap space - 300MB) used for execution and storage. The lower this is, the more frequently spills and cached data eviction occur. The purpose of this config is to set aside memory for internal metadata, user data structures, and imprecise size estimation in the case of sparse, unusually large records. Leaving this at the default value is recommended. For more detail, including important information about correctly tuning JVM garbage collection when increasing this value, see this description.
#申请的heap size-300M * 0.6 作为数据存储和数据运算的内存

******************可以调整，视代码情况而定，如果新生代使用多那就调整，如果年老带占用大那就跳大年老带等**************
spark.memory.storageFraction	0.5	Amount of storage memory immune to eviction, expressed as a fraction of the size of the region set aside by spark.memory.fraction. The higher this is, the less working memory may be available to execution and tasks may spill to disk more often. Leaving this at the default value is recommended. For more detail, see this description.
#上述的内存再*0.5作为存储的内存  另一0.5作为execution内存

***************可以调优，因为之前都已经配置了JVM、executor的堆外内存的使用了*******************
spark.memory.offHeap.enabled	false	If true, Spark will attempt to use off-heap memory for certain operations. If off-heap memory use is enabled, then spark.memory.offHeap.size must be positive.
#是否使用堆外内存

spark.memory.offHeap.size	0	The absolute amount of memory in bytes which can be used for off-heap allocation. This setting has no impact on heap memory usage, so if your executors' total memory consumption must fit within some hard limit then be sure to shrink your JVM heap size accordingly. This must be set to a positive value when spark.memory.offHeap.enabled=true.
#如果使用堆外内存的话，就需要设置堆外内存的大小

spark.memory.useLegacyMode	false	Whether to enable the legacy memory management mode used in Spark 1.5 and before. The legacy mode rigidly partitions the heap space into fixed-size regions, potentially leading to excessive spilling if the application was not tuned. The following deprecated memory fraction configurations are not read unless this is enabled:
#spark.shuffle.memoryFraction
#spark.storage.memoryFraction
#spark.storage.unrollFraction
#内存管理器，老版本可以使用

spark.shuffle.memoryFraction	0.2	(deprecated) This is read only if spark.memory.useLegacyMode is enabled. Fraction of Java heap to use for aggregation and cogroups during shuffles. At any given time, the collective size of all in-memory maps used for shuffles is bounded by this limit, beyond which the contents will begin to spill to disk. If spills are often, consider increasing this value at the expense of spark.storage.memoryFraction.

spark.storage.memoryFraction	0.6	(deprecated) This is read only if spark.memory.useLegacyMode is enabled. Fraction of Java heap to use for Spark's memory cache. This should not be larger than the "old" generation of objects in the JVM, which by default is given 0.6 of the heap, but you can increase it if you configure your own old generation size.
spark.storage.unrollFraction	0.2	(deprecated) This is read only if spark.memory.useLegacyMode is enabled. Fraction of spark.storage.memoryFraction to use for unrolling blocks in memory. This is dynamically allocated by dropping existing blocks when there is not enough free storage space to unroll the new block in its entirety.

spark.storage.replication.proactive	false	Enables proactive block replication for RDD blocks. Cached RDD block replicas lost due to executor failures are replenished if there are any existing available replicas. This tries to get the replication level of the block to the initial number.
#是否存副本

spark.cleaner.periodicGC.interval	30min	Controls how often to trigger a garbage collection.
#多久进行一个fll GC

#This context cleaner triggers cleanups only when weak references are garbage collected. In long-running applications with large driver JVMs, where there is little memory pressure on the driver, this may happen very occasionally or not at all. Not cleaning at all may lead to executors running out of disk space after a while.

spark.cleaner.referenceTracking	true	Enables or disables context cleaning.
#清洗context

spark.cleaner.referenceTracking.blocking	true	Controls whether the cleaning thread should block on cleanup tasks (other than shuffle, which is controlled by spark.cleaner.referenceTracking.blocking.shuffle Spark property).
#是否清理task产生的数据block

spark.cleaner.referenceTracking.blocking.shuffle	false	Controls whether the cleaning thread should block on shuffle cleanup tasks.
#是否清理shuffle 产生的block数据

spark.cleaner.referenceTracking.cleanCheckpoints	false	Controls whether to clean checkpoint files if the reference is out of scope.
#是否清理checkpoints files

Execution Behavior
spark.broadcast.blockSize	4m	Size of each piece of a block for TorrentBroadcastFactory, in KiB unless otherwise specified. Too large a value decreases parallelism during broadcast (makes it slower); however, if it is too small, BlockManager might take a performance hit.
#广播变量的block的大小，如果广播成功，则返回block的个数

spark.broadcast.checksum	true	Whether to enable checksum for broadcast. If enabled, broadcasts will include a checksum, which can help detect corrupted blocks, at the cost of computing and sending a little more data. It's possible to disable it if the network has other mechanisms to guarantee data won't be corrupted during broadcast.
#保证广播变量的完整性，就是校验数据的正确性

spark.executor.cores	1 in YARN mode, all the available cores on the worker in standalone and Mesos coarse-grained modes.	The number of cores to use on each executor. In standalone and Mesos coarse-grained modes, for more detail, see this description.
#通过submit提交参数

*********代码调优*************
spark.default.parallelism	For distributed shuffle operations like reduceByKey and join, the largest number of partitions in a parent RDD. For operations like parallelize with no parent RDDs, it depends on the cluster manager:
#分布式shuffle操作的并行度，默认是根据分区数来决定的
#Local mode: number of cores on the local machine
#Mesos fine grained mode: 8
#Others: total number of cores on all executor nodes or 2, whichever is larger
#Default number of partitions in RDDs returned by transformations like join, reduceByKey, and parallelize when not set by user.

spark.executor.heartbeatInterval	10s	Interval between each executor's heartbeats to the driver. Heartbeats let the driver know that the executor is still alive and update it with metrics for in-progress tasks. spark.executor.heartbeatInterval should be significantly less than spark.network.timeout
#executions的心跳间隔，需要小于网络time out的间隔

spark.files.fetchTimeout	60s	Communication timeout to use when fetching files added through SparkContext.addFile() from the driver.
#读取文件的timeout

spark.files.useFetchCache	true	If set to true (default), file fetching will use a local cache that is shared by executors that belong to the same application, which can improve task launching performance when running many executors on the same host. If set to false, these caching optimizations will be disabled and all executors will fetch their own copies of files. This optimization may be disabled in order to use Spark local directories that reside on NFS filesystems (see SPARK-6313 for more details).
#获取的文件是否要本地缓存，最好是这样

spark.files.overwrite	false	Whether to overwrite files added through SparkContext.addFile() when the target file exists and its contents do not match those of the source.
#是否要重写，如果文件内存不匹配的话那也没办法

spark.files.maxPartitionBytes	134217728 (128 MB)	The maximum number of bytes to pack into a single partition when reading files.
#一个分区包含的最大字节数 也就是128M

****************可以调整一下****************
spark.files.openCostInBytes	4194304 (4 MB)	The estimated cost to open a file, measured by the number of bytes could be scanned at the same time. This is used when putting multiple files into a partition. It is better to overestimate, then the partitions with small files will be faster than partitions with bigger files.
#小文件合并阈值，小于这个阈值放进一个partition

spark.hadoop.cloneConf	false	If set to true, clones a new Hadoop Configuration object for each task. This option should be enabled to work around Configuration thread-safety issues (see SPARK-2546 for more details). This is disabled by default in order to avoid unexpected performance regressions for jobs that are not affected by these issues.
#尽量不克隆配置，不然性能上可能存在倒退

spark.hadoop.validateOutputSpecs	true	If set to true, validates the output specification (e.g. checking if the output directory already exists) used in saveAsHadoopFile and other variants. This can be disabled to silence exceptions due to pre-existing output directories. We recommend that users do not disable this except if trying to achieve compatibility with previous versions of Spark. Simply use Hadoop's FileSystem API to delete output directories by hand. This setting is ignored for jobs generated through Spark Streaming's StreamingContext, since data may need to be rewritten to pre-existing output directories during checkpoint recovery.
#是否提前确认路径是否已经存在，不能写入已经存在的文件路径，目的是保护文件

spark.storage.memoryMapThreshold	2m	Size in bytes of a block above which Spark memory maps when reading a block from disk. This prevents Spark from memory mapping very small blocks. In general, memory mapping has high overhead for blocks close to or below the page size of the operating system.
#从磁盘读取的数据block映射到内存中的最小大小，开启内存是有花销的

spark.hadoop.mapreduce.fileoutputcommitter.algorithm.version	1	The file output committer algorithm version, valid algorithm version number: 1 or 2. Version 2 may have better performance, but version 1 may handle failures better in certain situations, as per MAPREDUCE-4815.
#文件输出commit的算法


Networking
spark.rpc.message.maxSize	128	Maximum message size (in MB) to allow in "control plane" communication; generally only applies to map output size information sent between executors and the driver. Increase this if you are running jobs with many thousands of map and reduce tasks and see messages about the RPC message size.
#rpc远程过程调用传输数据最大大小是128M

spark.blockManager.port	(random)	Port for all block managers to listen on. These exist on both the driver and the executors.
#block管理开启的端口是随机的

spark.driver.blockManager.port	(value of spark.blockManager.port)	Driver-specific port for the block manager to listen on, for cases where it cannot use the same configuration as executors.
#根据上面的而定，如果想和executor区分就给定一个

spark.driver.bindAddress	(value of spark.driver.host)	Hostname or IP address where to bind listening sockets. This config overrides the SPARK_LOCAL_IP environment variable (see below). 
#这个不能给定
#It also allows a different address from the local one to be advertised to executors or external systems. This is useful, for example, when running containers with bridged networking. For this to properly work, the different ports used by the driver (RPC, block manager and UI) need to be forwarded from the container's host.

spark.driver.host	(local hostname)	Hostname or IP address for the driver. This is used for communicating with the executors and the standalone Master.
#不能给定

spark.driver.port	(random)	Port for the driver to listen on. This is used for communicating with the executors and the standalone Master.
#随机给定

spark.network.timeout	120s	Default timeout for all network interactions. This config will be used in place of spark.core.connection.ack.wait.timeout, spark.storage.blockManagerSlaveTimeoutMs, spark.shuffle.io.connectionTimeout, spark.rpc.askTimeout or spark.rpc.lookupTimeout if they are not configured.
#这个配置是最终的timeout，如果其他的timeout没有设置，就用这个timeout

spark.port.maxRetries	16	Maximum number of retries when binding to a port before giving up. When a port is given a specific value (non 0), each subsequent retry will increment the port used in the previous attempt by 1 before retrying. This essentially allows it to try a range of ports from the start port specified to port + maxRetries.
#重试绑定端口的次数，实际上每次+1

spark.rpc.numRetries	3	Number of times to retry before an RPC task gives up. An RPC task will run at most times of this number.
#远程过程调用task重试次数

spark.rpc.retry.wait	3s	Duration for an RPC ask operation to wait before retrying.
#每次等3秒

spark.rpc.askTimeout	spark.network.timeout	Duration for an RPC ask operation to wait before timing out.
#在rpc执行过程中的timeout

spark.rpc.lookupTimeout	120s	Duration for an RPC remote endpoint lookup operation to wait before timing out.
#其实跟上面spark.rpc.askTimeOut差不多

spark.core.connection.ack.wait.timeout	spark.network.timeout	How long for the connection to wait for ack to occur before timing out and giving up. To avoid unwilling timeout caused by long pause like GC, you can set larger value.
#其实还是网络上的延时问题

Scheduling
spark.cores.max	(not set)	When running on a standalone deploy cluster or a Mesos cluster in "coarse-grained" sharing mode, the maximum amount of CPU cores to request for the application from across the cluster (not from each machine). If not set, the default will be spark.deploy.defaultCores on Spark's standalone cluster manager, or infinite (all available cores) on Mesos.
#这个在submit的时候计算

**************数据本地化可以调优***********
spark.locality.wait	3s	How long to wait to launch a data-local task before giving up and launching it on a less-local node. The same wait will be used to step through multiple locality levels (process-local, node-local, rack-local and then any). It is also possible to customize the waiting time for each level by setting spark.locality.wait.node, etc. You should increase this setting if your tasks are long and see poor locality, but the default usually works well.
#等待多久从单签local级别进入下一级别的locality data

spark.locality.wait.node	spark.locality.wait	Customize the locality wait for node locality. For example, you can set this to 0 to skip node locality and search immediately for rack locality (if your cluster has rack information).
#等待多久进行node-local，默认是上面配置的值

spark.locality.wait.process	spark.locality.wait	Customize the locality wait for process locality. This affects tasks that attempt to access cached data in a particular executor process.
#为了进入process-local能够等待多久，可以自己配置，默认是上面配置的值

spark.locality.wait.rack	spark.locality.wait	Customize the locality wait for rack locality.
#.......

spark.scheduler.maxRegisteredResourcesWaitingTime	30s	Maximum amount of time to wait for resources to register before scheduling begins.
#最长等待资源的时间

spark.scheduler.minRegisteredResourcesRatio	0.8 for KUBERNETES mode; 0.8 for YARN mode; 0.0 for standalone mode and Mesos coarse-grained mode	The minimum ratio of registered resources (registered resources / total expected resources) (resources are executors in yarn mode and Kubernetes mode, CPU cores in standalone mode and Mesos coarse-grained mode ['spark.cores.max' value is total expected resources for Mesos coarse-grained mode] ) to wait for before scheduling begins. Specified as a double between 0.0 and 1.0. Regardless of whether the minimum ratio of resources has been reached, the maximum amount of time it will wait before scheduling begins is controlled by config spark.scheduler.maxRegisteredResourcesWaitingTime.
#可以接受的最少的资源申请是上一个配置*0.8

spark.scheduler.mode	FIFO	The scheduling mode between jobs submitted to the same SparkContext. Can be set to FAIR to use fair sharing instead of queueing jobs one after another. Useful for multi-user services.
#先进先出的job安排，可以设置为FAIR模式用于多用户服务

spark.scheduler.revive.interval	1s	The interval length for the scheduler to revive the worker resource offers to run tasks.
#使复活

spark.scheduler.listenerbus.eventqueue.capacity	10000	Capacity for event queue in Spark listener bus, must be greater than 0. Consider increasing value (e.g. 20000) if listener events are dropped. Increasing this value may result in the driver using more memory.
#event事件监听，太多会占用内存

spark.blacklist.enabled	false	If set to "true", prevent Spark from scheduling tasks on executors that have been blacklisted due to too many task failures. The blacklisting algorithm can be further controlled by the other "spark.blacklist" configuration options.
#黑名单！！！！谁失败的多我就不用谁了，厉害了

spark.blacklist.timeout	1h	(Experimental) How long a node or executor is blacklisted for the entire application, before it is unconditionally removed from the blacklist to attempt running new tasks.
#进入黑名单之后过去1h之后再去运行，如果没失败就从黑名单出去除

spark.blacklist.task.maxTaskAttemptsPerExecutor	1	(Experimental) For a given task, how many times it can be retried on one executor before the executor is blacklisted for that task.
#executor试几次失败才把这个executor放进黑名单

spark.blacklist.task.maxTaskAttemptsPerNode	2	(Experimental) For a given task, how many times it can be retried on one node, before the entire node is blacklisted for that task.
#node试几次失败才把这个node放入黑名单

spark.blacklist.stage.maxFailedTasksPerExecutor	2	(Experimental) How many different tasks must fail on one executor, within one stage, before the executor is blacklisted for that stage.
#在一个stage中多少个不同的失败的task就把这个exectuor放入黑名单

spark.blacklist.stage.maxFailedExecutorsPerNode	2	(Experimental) How many different executors are marked as blacklisted for a given stage, before the entire node is marked as failed for the stage.
#.....

spark.blacklist.application.maxFailedTasksPerExecutor	2	(Experimental) How many different tasks must fail on one executor, in successful task sets, before the executor is blacklisted for the entire application. Blacklisted executors will be automatically added back to the pool of available resources after the timeout specified by spark.blacklist.timeout. Note that with dynamic allocation, though, the executors may get marked as idle and be reclaimed by the cluster manager.
#...

spark.blacklist.application.maxFailedExecutorsPerNode	2	(Experimental) How many different executors must be blacklisted for the entire application, before the node is blacklisted for the entire application. Blacklisted nodes will be automatically added back to the pool of available resources after the timeout specified by spark.blacklist.timeout. Note that with dynamic allocation, though, the executors on the node may get marked as idle and be reclaimed by the cluster manager.
#....

spark.blacklist.killBlacklistedExecutors	false	(Experimental) If set to "true", allow Spark to automatically kill the executors when they are blacklisted on fetch failure or blacklisted for the entire application, as controlled by spark.blacklist.application.*. Note that, when an entire node is added to the blacklist, all of the executors on that node will be killed.
#最好不要随意杀

spark.blacklist.application.fetchFailure.enabled	false	(Experimental) If set to "true", Spark will blacklist the executor immediately when a fetch failure happens. If external shuffle service is enabled, then the whole node will be blacklisted.
#不能冲动、不能随便下结论人家不行

spark.speculation	false	If set to "true", performs speculative execution of tasks. This means if one or more tasks are running slowly in a stage, they will be re-launched.
#不能随意重启tasks

spark.speculation.interval	100ms	How often Spark will check for tasks to speculate.
#...

spark.speculation.multiplier	1.5	How many times slower a task is than the median to be considered for speculation.
#...

spark.speculation.quantile	0.75	Fraction of tasks which must be complete before speculation is enabled for a particular stage.
#

spark.task.cpus	1	Number of cores to allocate for each task.
#每个task给定的cpu数

spark.task.maxFailures	4	Number of failures of any particular task before giving up on the job. The total number of failures spread across different tasks will not cause the job to fail; a particular task has to fail this number of attempts. Should be greater than or equal to 1. Number of allowed retries = this value - 1.
#任何一个task如果失败了4次就放弃这个job，重试次数是4-1

spark.task.reaper.enabled	false	Enables monitoring of killed / interrupted tasks. When set to true, any task which is killed will be monitored by the executor until that task actually finishes executing. See the other spark.task.reaper.* configurations for details on how to control the exact behavior of this monitoring. When set to false (the default), task killing will use an older code path which lacks such monitoring.
#是否有权限杀掉失效的task，这个参数真的可以设置为true

spark.task.reaper.pollingInterval	10s	When spark.task.reaper.enabled = true, this setting controls the frequency at which executors will poll the status of killed tasks. If a killed task is still running when polled then a warning will be logged and, by default, a thread-dump of the task will be logged (this thread dump can be disabled via the spark.task.reaper.threadDump setting, which is documented below).
#轮询检查被杀掉的task如果还在运行就记录WARN日志

spark.task.reaper.threadDump	true	When spark.task.reaper.enabled = true, this setting controls whether task thread dumps are logged during periodic polling of killed tasks. Set this to false to disable collection of thread dumps.
#线程回收是否产生日志

spark.task.reaper.killTimeout	-1	When spark.task.reaper.enabled = true, this setting specifies a timeout after which the executor JVM will kill itself if a killed task has not stopped running. The default value, -1, disables this mechanism and prevents the executor from self-destructing. The purpose of this setting is to act as a safety-net to prevent runaway noncancellable tasks from rendering an executor unusable.
#executor自杀....最好不要

spark.stage.maxConsecutiveAttempts	4	Number of consecutive stage attempts allowed before a stage is aborted.
#一个stage要连续尝试多少次后被遗弃

Dynamic Allocation
spark.dynamicAllocation.enabled	false	Whether to use dynamic resource allocation, which scales the number of executors registered with this application up and down based on the workload. For more detail, see the description here. 
#动态资源配置，如果需要使用外部shuffle，就需要动态申请资源
#This requires spark.shuffle.service.enabled to be set. The following configurations are also relevant: spark.dynamicAllocation.minExecutors, spark.dynamicAllocation.maxExecutors, and spark.dynamicAllocation.initialExecutors spark.dynamicAllocation.executorAllocationRatio

spark.dynamicAllocation.executorIdleTimeout	60s	If dynamic allocation is enabled and an executor has been idle for more than this duration, the executor will be removed. For more detail, see this description.
#如果一个executor闲来无事超过这个时间就收回资源

spark.dynamicAllocation.cachedExecutorIdleTimeout	infinity	If dynamic allocation is enabled and an executor which has cached data blocks has been idle for more than this duration, the executor will be removed. For more details, see this description.
#如果一个exector虽然缓存了数据但是一直不用超过这个时间也会被收回资源，但是这个时间是无限的...

spark.dynamicAllocation.initialExecutors	spark.dynamicAllocation.minExecutors	Initial number of executors to run if dynamic allocation is enabled. 
#如果是动态资源配置，那么初始化多少个？
#If `--num-executors` (or `spark.executor.instances`) is set and larger than this value, it will be used as the initial number of executors.

spark.dynamicAllocation.maxExecutors	infinity	Upper bound for the number of executors if dynamic allocation is enabled.
#最多可以动态配置多少个executor，肯定不能无限！！！！

spark.dynamicAllocation.minExecutors	0	Lower bound for the number of executors if dynamic allocation is enabled.
#最少当然可以是0，没有数据可处理嘛

spark.dynamicAllocation.executorAllocationRatio	1	By default, the dynamic allocation will request enough executors to maximize the parallelism according to the number of tasks to process. While this minimizes the latency of the job, with small tasks this setting can waste a lot of resources due to executor allocation overhead, as some executor might not even do any work. This setting allows to set a ratio that will be used to reduce the number of executors w.r.t. full parallelism. Defaults to 1.0 to give maximum parallelism. 0.5 will divide the target number of executors by 2 The target number of executors computed by the dynamicAllocation can still be overridden by the spark.dynamicAllocation.minExecutors and spark.dynamicAllocation.maxExecutors settings
#为保证最大的并行度，比例是1

spark.dynamicAllocation.schedulerBacklogTimeout	1s	If dynamic allocation is enabled and there have been pending tasks backlogged for more than this duration, new executors will be requested. For more detail, see this description.
#如果任务请求延迟超过这个1s的时候就会申请新的executors

spark.dynamicAllocation.sustainedSchedulerBacklogTimeout	schedulerBacklogTimeout	Same as spark.dynamicAllocation.schedulerBacklogTimeout, but used only for subsequent executor requests. For more detail, see this description.
#和上个配置一个意思，但是应用在下一次

Spark Streaming
spark.streaming.backpressure.enabled	false	Enables or disables Spark Streaming's internal backpressure mechanism (since 1.5). This enables the Spark Streaming to control the receiving rate based on the current batch scheduling delays and processing times so that the system receives only as fast as the system can process. Internally, this dynamically sets the maximum receiving rate of receivers. This rate is upper bounded by the values spark.streaming.receiver.maxRate and spark.streaming.kafka.maxRatePerPartition if they are set (see below).
#背压，控制streaming 的 recieve rete，防止压力太大，保证recive和process相平衡

spark.streaming.backpressure.initialRate	not set	This is the initial maximum receiving rate at which each receiver will receive data for the first batch when the backpressure mechanism is enabled.
#初始rate

spark.streaming.blockInterval	200ms	Interval at which data received by Spark Streaming receivers is chunked into blocks of data before storing them in Spark. Minimum recommended - 50 ms. See the performance tuning section in the Spark Streaming programing guide for more details.
#recieve 接收data的过程是根据这个interval来创建datablock

spark.streaming.receiver.maxRate	not set	Maximum rate (number of records per second) at which each receiver will receive data. Effectively, each stream will consume at most this number of records per second. Setting this configuration to 0 or a negative number will put no limit on the rate. See the deployment guide in the Spark Streaming programing guide for mode details.
#最大率 每个reciever每秒接收多少条记录，最好还是不要限制了

spark.streaming.receiver.writeAheadLog.enable	false	Enable write-ahead logs for receivers. All the input data received through receivers will be saved to write-ahead logs that will allow it to be recovered after driver failures. See the deployment guide in the Spark Streaming programing guide for more details.
#接收数据是否要用WAL，如果使用了可以在在driver失败之后恢复，其实有很多其他方式达到exactly once 和at least once

spark.streaming.unpersist	true	Force RDDs generated and persisted by Spark Streaming to be automatically unpersisted from Spark's memory. The raw input data received by Spark Streaming is also automatically cleared. Setting this to false will allow the raw data and persisted RDDs to be accessible outside the streaming application as they will not be cleared automatically. But it comes at the cost of higher memory usage in Spark.
#是否自动吧不需要的rdd从缓存中清楚？  当然

spark.streaming.stopGracefullyOnShutdown	false	If true, Spark shuts down the StreamingContext gracefully on JVM shutdown rather than immediately.
#可以立即关闭

spark.streaming.kafka.maxRatePerPartition	not set	Maximum rate (number of records per second) at which data will be read from each Kafka partition when using the new Kafka direct stream API. See the Kafka Integration guide for more details.
#接收kafka每个partition的最大rate，默认是根据genarate来的

spark.streaming.kafka.minRatePerPartition	1	Minimum rate (number of records per second) at which data will be read from each Kafka partition when using the new Kafka direct stream API.
#....

spark.streaming.kafka.maxRetries	1	Maximum number of consecutive retries the driver will make in order to find the latest offsets on the leader of each partition (a default value of 1 means that the driver will make a maximum of 2 attempts). Only applies to the new Kafka direct stream API.
#最多两次去找到最新的offset

spark.streaming.ui.retainedBatches	1000	How many batches the Spark Streaming UI and status APIs remember before garbage collecting.
#ui上保留最多的处理batch数

spark.streaming.driver.writeAheadLog.closeFileAfterWrite	false	Whether to close the file after writing a write-ahead log record on the driver. Set this to 'true' when you want to use S3 (or any file system that does not support flushing) for the metadata WAL on the driver.
#如果开启了WAL，用完文件是否需要关闭，一般的文件系统不用

spark.streaming.receiver.writeAheadLog.closeFileAfterWrite	false	Whether to close the file after writing a write-ahead log record on the receivers. Set this to 'true' when you want to use S3 (or any file system that does not support flushing) for the data WAL on the receivers.
#如果开启了WAL，写完WAL是否关闭文件，没必要